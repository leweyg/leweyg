<!DOCTYPE html>
<html>
<title>Polyhedral Transitions</title>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css">
<link rel='stylesheet' href='https://fonts.googleapis.com/css?family=Roboto'>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
<style>
html,body,h1,h2,h3,h4,h5,h6 {font-family: "Roboto", sans-serif}
</style>
<body class="w3-light-grey" onresize="updateGraphWindowSize()">

    
<header class="w3-container w3-light-grey w3-center w3-margin-top">
  <p class="w3-right-align" style="display: none;">Polyhedra Demo</p>
</header> 

<!-- Page Container -->
<div class="w3-content w3-margin-top" style="max-width:1400px;">

  <!-- The Grid -->
  <div class="w3-row-padding">
  
    <!-- Right Column -->
    <div class="">
    
      <div class="w3-container w3-card w3-white w3-margin-bottom">
        <h2 class="w3-text-grey w3-padding-16"><i class="fa fa-suitcase fa-fw w3-margin-right w3-xxlarge w3-text-teal"></i>Demo</h2>
        <div class="w3-container">
          <p>Before Canvas</p>
          <div id="view3d_div">
          <canvas id="view3d_canvas" height="400" width="711" >
            </canvas>
          </div>
          <div>
              <input type="range" min="0" max="3" value="0.5" step="0.05" class="slider" 
              id="mainRangeSlider">
              <script>
                mainRangeSlider.oninput = function() {
                  updateMapInerp(mainRangeSlider.value);
                }
              </script>
          </div>
          <p><span id="mainNameFrom">Name from</span> <span id="mainNameTo">Name to</span></p>
        </div>
      
      </div>
      <script src="three.js"></script>
      <script src="evx_core.js"></script>
      <script src="evn_3d.js"></script>
      <script src="polyhedra.js"></script>
      <script>
        var e3 = evn3d_init(view3d_canvas); 

        e3.userRequestedUpdate = function() {
          e3.requestUpdate();
        };
        var isFirstResize = true;

        function updateGraphWindowSize() {
				var fw = getComputedStyle(view3d_div).width;// view3d_div.cientWidth;
				if (fw != undefined) {
					if (("" + fw).includes("px")) {
						fw = "" + fw;
						fw = 1.0*(fw.substring(0,fw.length-2));
					}
					fw = Math.max( 100, fw - 10 );
					var idealAspect = (8.0 / 16.0);// (7.0 / 16.0);
					view3d_canvas.width = Math.floor( fw );
          view3d_canvas.height = Math.floor( fw * idealAspect );
          mainRangeSlider.style.width = Math.floor( fw ) + "px";
					if (isFirstResize && (view3d_canvas.height < 180)) {
					}
					isFirstResize = false;
					//alert("New size = " + view3d_canvas.width);
					if (evxToolsNotNull(e3)) {
						e3.requestUpdate();
					}
				}
      }
      
          updateGraphWindowSize();
        </script>
        <script>
          function packedArrayFromSubArrays(arOfArs) {
            var ans = [];
            for (var vi in arOfArs) {
              var vd = arOfArs[vi];
              for (var di in vd) {
                ans.push(vd[di]);
              }
            }
            return ans;
          }
          function facesToTriIndicies(arOfArs) {
            var ans = [];
            for (var vi in arOfArs) {
              var vd = arOfArs[vi];
              for (var di in vd) {
                if (di < 3) {
                  ans.push(vd[di]);
                } else {
                  ans.push(vd[0]);
                  ans.push(vd[di-1]);
                  ans.push(vd[di]);
                }
              }
            }
            return ans;
          }
          function obj3FromPoly(poly) {
            var group = new THREE.Group();

            if (true) {
              // custom poly:
              var positions = packedArrayFromSubArrays(poly.vertex);
              var posData = new THREE.Float32BufferAttribute( positions, 3 );
              var bufferGeo = new THREE.BufferGeometry();
              bufferGeo.addAttribute( 'position', posData );
              bufferGeo.setIndex( facesToTriIndicies(poly.face) );
              bufferGeo.computeBoundingSphere();

              //var mat = new THREE.MeshNormalMaterial();
              var defColor = new THREE.Color( 0xA9F3B3 );
              var mat = evxShaderMaterialCreateForLitTriangles(defColor);
              mat.side = THREE.DoubleSide;
              var mesh = new THREE.Mesh( bufferGeo, mat );
              group.add( mesh );
            } else {
              // pre-made cube:
              var geometry = new THREE.BoxGeometry( 1, 1, 1 );
              var mat = new THREE.MeshNormalMaterial();
              var mesh = new THREE.Mesh( geometry, mat );
              group.add( mesh );
            }

            evn3d_root.scene.add( group );
          }

          function vertexDist(va, vb) {
            let dist = 0;
            for (var i in va) {
              let d = va[i] - vb[i];
              dist += (d * d);
            }
            return Math.sqrt(dist);
          }

          function closestVertexIndex(verts, v, vi, list) {
            //return (vi % verts.length);
            let bestDist = vertexDist(verts[0], v);
            let bestIndex = 0;
            for (let vi in verts) {
              if ((list) && (vi in list)) {
                continue;
              }
              let d = vertexDist(verts[vi], v);
              if (d < bestDist) {
                bestDist = d;
                bestIndex = vi;
              }
            }
            return bestIndex;
          }

          function indexMappingFromPolySmToLg(polySm, polyLg) {
            var mapping = {};
            evxToolsAssert(polyLg.vertex.length >= polySm.vertex.length);
            for (let vii in polySm.vertex) {
              var bli = closestVertexIndex(polyLg.vertex, polySm.vertex[vii], vii, mapping);
              mapping[bli] = vii;
            }
            for (let vii in polyLg.vertex) {
              let vi = vii;
              if (!(vi in mapping)) {
                mapping[vi] = closestVertexIndex(polySm.vertex, polyLg.vertex[vi], vi);
              }
            }
            var smToLgMap = {};
            for (let li in mapping) {
              var si = mapping[li];
              if (true || !(si in smToLgMap)) {
                smToLgMap[si] = li;
              }

            }
            var buffer = [];
            while (buffer.length < polyLg.vertex.length * 3) {
              buffer.push(0);
            }
            return {
              'mapping' : mapping,
              'smToLgMap': smToLgMap,
              'polySm' : polySm,
              'polyLg' : polyLg,
              'buffer' : buffer,
            };
          }

          function interpolatePositions(map, t) {
            var oi = 0;
            for (var vi in map.polyLg.vertex) {
              var lv = map.polyLg.vertex[vi];
              var sv = map.polySm.vertex[ map.mapping[vi] ];
              for (var di in lv) {
                map.buffer[oi++] = evxToolsLerp(sv[di], lv[di], t);
              }
            }
            return map.buffer;
          }

          var mainSharedMaterial = undefined;

          function createInterpolatedPoly(polyA, polyB) {
            //var group = new THREE.Group();

            var polySm = polyA;
            var polyLg = polyB;
            if (polyA.vertex.length > polyB.vertex.length) {
              polyLg = polyA; polySm = polyB;
            }
            var map = indexMappingFromPolySmToLg(polySm, polyLg);
            var poses = interpolatePositions(map, 0.75);

            if (true)
            {
              // custom poly:
              var positions = packedArrayFromSubArrays(polyLg.vertex);
              var posData = new THREE.Float32BufferAttribute( poses, 3 );
              posData.dynamic = true;
              map.threeBuffer = posData;
              //map.buffer = posData.array;
              var bufferGeo = new THREE.BufferGeometry();
              bufferGeo.addAttribute( 'position', posData );
              var smIndices = facesToTriIndicies(polySm.face);
              for (let ii in smIndices) {
                smIndices[ii] = map.smToLgMap[ smIndices[ii] ];
              }
              bufferGeo.setIndex( facesToTriIndicies(polyLg.face).concat(smIndices) );
              bufferGeo.computeBoundingSphere();

              //var mat = new THREE.MeshNormalMaterial();
              var defColor = new THREE.Color( 0xA9F3B3 );
              var mat = mainSharedMaterial;
              if (!mat) {
                mat = evxShaderMaterialCreateForLitTriangles(defColor);
                mat.side = THREE.DoubleSide;
                mainSharedMaterial = mat;
              }
              var mesh = new THREE.Mesh( bufferGeo, mat );
              map.mesh = mesh;
              //group.add( mesh );
              evn3d_root.scene.add( mesh );
            }
            

            return map;
          }

          var mainLatestTransition = null;


          function sortPolysByFaces() {
            var list = [];
            var secondary = {};
            for (var name in POLYHEDRA) {
                var p = POLYHEDRA[name];
                p.name = name;
                if (!name.startsWith("J")) {
                  list.push(p);
                } else {
                  if (!(p.vertex.length in secondary)){
                    secondary[p.vertex.length] = p;
                  }
                }
              }
            list.sort(function(a,b) { return a.vertex.length - b.vertex.length; })
            var ans = [];
            var cur = undefined;
            for (let ii in list) {
              var p = list[ii];
              if ((!cur) || (cur.vertex.length < p.vertex.length)) {
                let clen = ((!cur) ? p.vertex.length : cur.vertex.length ) + 1;
                while (clen < p.vertex.length) {
                  if (clen in secondary) {
                    ans.push(secondary[clen]);
                  }
                  clen++;
                }
                
                cur = p;
                ans.push(cur);
              }
            }
            return ans;
          }
          var AllPolysForTransitions = sortPolysByFaces();
          var AllTransitions = [];

          function buildAllTransitions() {
            for (let iii in AllPolysForTransitions) {
              let ii = 1 * iii;
              if (ii+1 < AllPolysForTransitions.length) {
                let tr = createInterpolatedPoly(AllPolysForTransitions[ii], AllPolysForTransitions[ii+1]);
                tr.mesh.visible = false;
                AllTransitions.push(tr);
              }
            }
            mainLatestTransition = AllTransitions[0];
            mainLatestTransition.mesh.visible = true;
            mainRangeSlider.max = AllTransitions.length - 0;
          }
          buildAllTransitions();


          //obj3FromPoly(POLYHEDRA.Tetrahedron);
          //obj3FromPoly(POLYHEDRA.TriangularPrism);
          //mainLatestTransition = createInterpolatedPoly(POLYHEDRA.Tetrahedron, POLYHEDRA.TriangularPrism);
          //mainLatestTransition = createInterpolatedPoly(POLYHEDRA.TriangularPrism, POLYHEDRA.Cube);


          function updateMapInerp(t) {
            if (!mainLatestTransition) {
              return;
            }

            let ft = t - Math.floor(t);
            mainLatestTransition.mesh.visible = false;
            mainLatestTransition = AllTransitions[Math.min(Math.floor(t),AllTransitions.length-1)];
            mainLatestTransition.mesh.visible = true;

            mainLatestTransition.buffer = mainLatestTransition.threeBuffer.array;
            interpolatePositions(mainLatestTransition,ft);
            mainLatestTransition.threeBuffer.needsUpdate = true;
            e3.requestUpdate();

            mainNameFrom.innerHTML = mainLatestTransition.polySm.name;
            mainNameTo.innerHTML = mainLatestTransition.polyLg.name;
          }

        </script>

      <div class="w3-container w3-card w3-white">
        <h2 class="w3-text-grey w3-padding-16"><i class="fa fa-certificate fa-fw w3-margin-right w3-xxlarge w3-text-teal"></i>Education</h2>
        <div class="w3-container">
          <p id="mainGeoDescriptions">Geometric shapes: loading...</p>
          <script>
            function infoAboutPolys() {
              var ans = "";
              var from = AllPolysForTransitions;
              for (var ii in from) {
                var p = from[ii];
                ans += "" + p.name + " has " + p.vertex.length + " vertices<br/>";
              }
              mainGeoDescriptions.innerHTML = ans;
            }
            infoAboutPolys();
          </script>
        </div>
      </div>

    <!-- End Right Column -->
    </div>
    
  <!-- End Grid -->
  </div>
  
  <!-- End Page Container -->
</div>

    
<footer class="w3-container w3-teal w3-center w3-margin-top">
  <p>Find me on social media.</p>
  <i class="fa fa-facebook-official w3-hover-opacity"></i>
  <i class="fa fa-instagram w3-hover-opacity"></i>
  <i class="fa fa-snapchat w3-hover-opacity"></i>
  <i class="fa fa-pinterest-p w3-hover-opacity"></i>
  <i class="fa fa-twitter w3-hover-opacity"></i>
  <i class="fa fa-linkedin w3-hover-opacity"></i>
  <p>Powered by <a href="https://www.w3schools.com/w3css/default.asp" target="_blank">w3.css</a></p>
</footer>

</body>
</html>
